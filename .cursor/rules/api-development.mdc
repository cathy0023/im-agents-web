---
globs: src/lib/api.ts,src/lib/sse.ts,src/lib/**/*.ts
---

# API å¼€å‘è§„èŒƒ

## ğŸŒ API æ¶æ„åŸåˆ™

### é›†ä¸­åŒ– API ç®¡ç†
å‚è€ƒ [src/lib/api.ts](mdc:src/lib/api.ts) çš„å®ç°æ¨¡å¼ï¼š
- æ‰€æœ‰ API è°ƒç”¨é›†ä¸­åœ¨ `src/lib/` ç›®å½•
- ä½¿ç”¨ç»Ÿä¸€çš„é”™è¯¯å¤„ç†
- å®ç°ç±»å‹å®‰å…¨çš„æ¥å£

### API æ¨¡å—ç»“æ„
```typescript
// âœ… API æ¨¡å—ç»„ç»‡
export const chatApi = {
  sendMessage: async (message: string, agentId: number) => {},
  getHistory: async (agentId: number) => {},
  clearHistory: async (agentId: number) => {}
}

export const userApi = {
  getProfile: async () => {},
  updateProfile: async (data: UpdateProfileData) => {}
}
```

## ğŸ“¡ HTTP å®¢æˆ·ç«¯è§„èŒƒ

### ä½¿ç”¨ axios è¿›è¡Œè¯·æ±‚
```typescript
// âœ… ç»Ÿä¸€çš„ axios é…ç½®
import axios from 'axios'

const apiClient = axios.create({
  baseURL: process.env.VITE_API_BASE_URL || '/api',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// âœ… è¯·æ±‚æ‹¦æˆªå™¨
apiClient.interceptors.request.use(
  (config) => {
    const token = getAuthToken()
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  }
)

// âœ… å“åº”æ‹¦æˆªå™¨
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    handleApiError(error)
    return Promise.reject(error)
  }
)
```

## ğŸ” è®¤è¯å’Œæˆæƒ

### API Key ç®¡ç†
å‚è€ƒé¡¹ç›®ä¸­çš„å®ç°ï¼š
```typescript
// âœ… å®‰å…¨çš„ API Key å¤„ç†
const getApiKey = (): string | null => {
  return useChatStore.getState().apiKey
}

const setAuthHeader = (apiKey: string) => {
  apiClient.defaults.headers.common['Authorization'] = `Bearer ${apiKey}`
}

// âœ… æ£€æŸ¥ API Key æœ‰æ•ˆæ€§
const validateApiKey = async (apiKey: string): Promise<boolean> => {
  try {
    await apiClient.get('/validate', {
      headers: { Authorization: `Bearer ${apiKey}` }
    })
    return true
  } catch {
    return false
  }
}
```

## ğŸ”„ Server-Sent Events (SSE)

### SSE å®ç°è§„èŒƒ
å‚è€ƒ [src/lib/sse.ts](mdc:src/lib/sse.ts)ï¼š
```typescript
// âœ… SSE è¿æ¥ç®¡ç†
class SSEConnection {
  private eventSource: EventSource | null = null
  
  connect(url: string, options: SSEOptions) {
    this.eventSource = new EventSource(url)
    
    this.eventSource.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data)
        this.handleMessage(data)
      } catch (error) {
        console.error('Failed to parse SSE message:', error)
      }
    }
    
    this.eventSource.onerror = (error) => {
      this.handleError(error)
    }
  }
  
  disconnect() {
    if (this.eventSource) {
      this.eventSource.close()
      this.eventSource = null
    }
  }
}
```

### æµå¼å“åº”å¤„ç†
```typescript
// âœ… å¤„ç†æµå¼æ•°æ®
const handleStreamMessage = (message: StreamMessage) => {
  switch (message.type) {
    case 'content':
      updateMessageContent(message.data)
      break
    case 'finished':
      markMessageComplete(message.messageId)
      break
    case 'error':
      handleStreamError(message.error)
      break
  }
}
```

## ğŸ“ ç±»å‹å®šä¹‰è§„èŒƒ

### API å“åº”ç±»å‹
```typescript
// âœ… æ ‡å‡†å“åº”æ ¼å¼
interface ApiResponse<T = any> {
  data: T
  success: boolean
  message?: string
  error?: string
  timestamp: string
}

// âœ… åˆ†é¡µå“åº”
interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number
    limit: number
    total: number
    totalPages: number
  }
}

// âœ… é”™è¯¯å“åº”
interface ApiError {
  code: string
  message: string
  details?: Record<string, any>
  statusCode: number
}
```

### è¯·æ±‚å‚æ•°ç±»å‹
```typescript
// âœ… è¯·æ±‚å‚æ•°æ¥å£
interface SendMessageRequest {
  message: string
  agentId: number
  conversationId?: string
  stream?: boolean
}

interface GetHistoryRequest {
  agentId: number
  page?: number
  limit?: number
  startDate?: string
  endDate?: string
}
```

## âš¡ é”™è¯¯å¤„ç†

### ç»Ÿä¸€é”™è¯¯å¤„ç†
```typescript
// âœ… é”™è¯¯å¤„ç†å‡½æ•°
const handleApiError = (error: unknown): ApiError => {
  if (axios.isAxiosError(error)) {
    const response = error.response
    
    if (response) {
      return {
        code: response.data?.code || 'HTTP_ERROR',
        message: response.data?.message || error.message,
        statusCode: response.status,
        details: response.data?.details
      }
    }
    
    return {
      code: 'NETWORK_ERROR',
      message: 'Network connection failed',
      statusCode: 0
    }
  }
  
  return {
    code: 'UNKNOWN_ERROR',
    message: error instanceof Error ? error.message : 'Unknown error',
    statusCode: 0
  }
}

// âœ… åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
const sendMessage = async (content: string) => {
  try {
    const response = await chatApi.sendMessage(content, selectedAgent)
    // å¤„ç†æˆåŠŸå“åº”
  } catch (error) {
    const apiError = handleApiError(error)
    console.error('Failed to send message:', apiError)
    
    // ç”¨æˆ·å‹å¥½çš„é”™è¯¯æç¤º
    if (apiError.code === 'UNAUTHORIZED') {
      showError('è¯·æ£€æŸ¥æ‚¨çš„ API Key è®¾ç½®')
    } else {
      showError('å‘é€æ¶ˆæ¯å¤±è´¥ï¼Œè¯·é‡è¯•')
    }
  }
}
```

## ğŸ”„ é‡è¯•å’Œé™çº§ç­–ç•¥

### è‡ªåŠ¨é‡è¯•æœºåˆ¶
```typescript
// âœ… é‡è¯•é…ç½®
const retryConfig = {
  retries: 3,
  retryDelay: 1000,
  retryCondition: (error: AxiosError) => {
    // åªå¯¹ç½‘ç»œé”™è¯¯å’Œ 5xx é”™è¯¯é‡è¯•
    return !error.response || error.response.status >= 500
  }
}

// âœ… å®ç°é‡è¯•é€»è¾‘
const withRetry = async <T>(
  apiCall: () => Promise<T>,
  config = retryConfig
): Promise<T> => {
  let lastError: Error
  
  for (let attempt = 0; attempt <= config.retries; attempt++) {
    try {
      return await apiCall()
    } catch (error) {
      lastError = error as Error
      
      if (attempt === config.retries) break
      if (!config.retryCondition(error as AxiosError)) break
      
      await delay(config.retryDelay * Math.pow(2, attempt))
    }
  }
  
  throw lastError
}
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### è¯·æ±‚å»é‡
```typescript
// âœ… é˜²æ­¢é‡å¤è¯·æ±‚
const pendingRequests = new Map<string, Promise<any>>()

const deduplicateRequest = <T>(
  key: string,
  requestFn: () => Promise<T>
): Promise<T> => {
  if (pendingRequests.has(key)) {
    return pendingRequests.get(key)!
  }
  
  const promise = requestFn().finally(() => {
    pendingRequests.delete(key)
  })
  
  pendingRequests.set(key, promise)
  return promise
}
```

### è¯·æ±‚ç¼“å­˜
```typescript
// âœ… ç®€å•ç¼“å­˜å®ç°
const cache = new Map<string, { data: any; timestamp: number }>()
const CACHE_DURATION = 5 * 60 * 1000 // 5åˆ†é’Ÿ

const withCache = async <T>(
  key: string,
  requestFn: () => Promise<T>,
  duration = CACHE_DURATION
): Promise<T> => {
  const cached = cache.get(key)
  
  if (cached && Date.now() - cached.timestamp < duration) {
    return cached.data
  }
  
  const data = await requestFn()
  cache.set(key, { data, timestamp: Date.now() })
  
  return data
}
```

## ğŸ“Š ç›‘æ§å’Œæ—¥å¿—

### API è°ƒç”¨ç›‘æ§
```typescript
// âœ… è¯·æ±‚æ—¥å¿—
const logApiCall = (config: AxiosRequestConfig, duration: number) => {
  console.log(`[API] ${config.method?.toUpperCase()} ${config.url} - ${duration}ms`)
}

// âœ… æ€§èƒ½ç›‘æ§
apiClient.interceptors.request.use((config) => {
  config.metadata = { startTime: Date.now() }
  return config
})

apiClient.interceptors.response.use(
  (response) => {
    const duration = Date.now() - response.config.metadata.startTime
    logApiCall(response.config, duration)
    return response
  }
)
```

## âœ… API å¼€å‘æ£€æŸ¥æ¸…å•

### å¼€å‘å‰æ£€æŸ¥
- [ ] API æ¥å£æ˜¯å¦å·²å®šä¹‰ç±»å‹ï¼Ÿ
- [ ] é”™è¯¯å¤„ç†ç­–ç•¥æ˜¯å¦æ˜ç¡®ï¼Ÿ
- [ ] æ˜¯å¦éœ€è¦è®¤è¯ï¼Ÿ

### å¼€å‘ä¸­æ£€æŸ¥
- [ ] æ˜¯å¦ä½¿ç”¨äº†ç»Ÿä¸€çš„é”™è¯¯å¤„ç†ï¼Ÿ
- [ ] æ˜¯å¦æ­£ç¡®å¤„ç†äº†å¼‚æ­¥æ“ä½œï¼Ÿ
- [ ] æ˜¯å¦è€ƒè™‘äº†é‡è¯•å’Œé™çº§ï¼Ÿ

### æµ‹è¯•æ£€æŸ¥
- [ ] æ­£å¸¸æƒ…å†µä¸‹æ˜¯å¦å·¥ä½œæ­£å¸¸ï¼Ÿ
- [ ] ç½‘ç»œé”™è¯¯æ—¶æ˜¯å¦æ­£ç¡®å¤„ç†ï¼Ÿ
- [ ] è®¤è¯å¤±è´¥æ—¶æ˜¯å¦æœ‰åˆé€‚çš„æç¤ºï¼Ÿ
- [ ] æ€§èƒ½æ˜¯å¦æ»¡è¶³è¦æ±‚ï¼Ÿ